<?xml version="1.1" encoding="UTF-8" standalone="no"?><flow-definition plugin="workflow-job@2.41">
  <actions>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobAction plugin="pipeline-model-definition@1.8.5"/>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction plugin="pipeline-model-definition@1.8.5">
      <jobProperties/>
      <triggers/>
      <parameters/>
      <options/>
    </org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction>
  </actions>
  <description>Gitee平台mindspore门禁流水线&#13;
</description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <hudson.plugins.jira.JiraProjectProperty plugin="jira@3.3"/>
    <jenkins.model.BuildDiscarderProperty>
      <strategy class="hudson.tasks.LogRotator">
        <daysToKeep>30</daysToKeep>
        <numToKeep>2000</numToKeep>
        <artifactDaysToKeep>-1</artifactDaysToKeep>
        <artifactNumToKeep>-1</artifactNumToKeep>
      </strategy>
    </jenkins.model.BuildDiscarderProperty>
    <com.gitee.jenkins.connection.GiteeConnectionProperty plugin="gitee@1.2.4">
      <giteeConnection>gitee</giteeConnection>
    </com.gitee.jenkins.connection.GiteeConnectionProperty>
    <com.sonyericsson.rebuild.RebuildSettings plugin="rebuild@1.32">
      <autoRebuild>false</autoRebuild>
      <rebuildDisabled>false</rebuildDisabled>
    </com.sonyericsson.rebuild.RebuildSettings>
    
    <org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty>
      <triggers>
        <com.gitee.jenkins.trigger.GiteePushTrigger plugin="gitee@1.2.4">
          <spec/>
          <triggerOnPush>false</triggerOnPush>
          <triggerOnCommitComment>false</triggerOnCommitComment>
          <triggerOnOpenPullRequest>false</triggerOnOpenPullRequest>
          <triggerOnPipelineEvent>false</triggerOnPipelineEvent>
          <triggerOnAcceptedPullRequest>false</triggerOnAcceptedPullRequest>
          <triggerOnUpdatePullRequest>0</triggerOnUpdatePullRequest>
          <triggerOnClosedPullRequest>false</triggerOnClosedPullRequest>
          <triggerOnApprovedPullRequest>false</triggerOnApprovedPullRequest>
          <triggerOnTestedPullRequest>false</triggerOnTestedPullRequest>
          <triggerOnNoteRequest>true</triggerOnNoteRequest>
          <noteRegex>/retest3</noteRegex>
          <buildInstructionFilterType>NONE</buildInstructionFilterType>
          <skipWorkInProgressPullRequest>false</skipWorkInProgressPullRequest>
          <ciSkipFroTestNotRequired>false</ciSkipFroTestNotRequired>
          <skipLastCommitHasBeenBuild>false</skipLastCommitHasBeenBuild>
          <setBuildDescription>true</setBuildDescription>
          <branchFilterType>All</branchFilterType>
          <includeBranchesSpec>master,r0.5</includeBranchesSpec>
          <excludeBranchesSpec>r0.3</excludeBranchesSpec>
          <targetBranchRegex/>
          <secretToken>{AQAAABAAAAAwm6vRmigN9Z43qhCru1Yp3Fmsgd1gwopP6/Apm+N15S8kIt2pEV1y0jF1uNwUoffh+Ikx8Dq/jY/w6DkWkBn3zA==}</secretToken>
          <cancelPendingBuildsOnUpdate>false</cancelPendingBuildsOnUpdate>
          <cancelIncompleteBuildOnSamePullRequest>false</cancelIncompleteBuildOnSamePullRequest>
          <ignorePullRequestConflicts>false</ignorePullRequestConflicts>
        </com.gitee.jenkins.trigger.GiteePushTrigger>
      </triggers>
    </org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty>
  </properties>
  <definition class="org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition" plugin="workflow-cps@2.92">
    <script>/*
# Copyright 2021 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
*/

/*
################
# Pipeline env #
################
*/
def setEnvCI(String sourceBranch) {
    env.CODE_PATH = "/home/jenkins/share-data/${CODE_PLATFORM}/${ORGANIZATION_NAME}/${REPOSITORY_NAME}/code/${PIPELINE_TYPE}/${BUILD_ID}"
    
    // Jumper node IP for smoke test(big IP, small IP)
    env.SHARE_COMPUTER_BIG_IP = '114.116.220.20'
    env.SHARE_COMPUTER_SMALL_IP = '192.168.0.240'
    
    // If upgrade ascend
    if (sourceBranch =~ 'upgrade_ascend') {
        env.CI_PIPELINE_ORGANIZATION_NAME = "${giteeSourceNamespace}"
        env.CI_PIPELINE_BRANCH = "${giteeSourceBranch}"
    } else {
        env.CI_PIPELINE_ORGANIZATION_NAME = 'wmzheng2020'
        env.CI_PIPELINE_BRANCH = 'branch'
    }
}

def setEnvGate(String platformType='gitee') {
    env.PIPELINE_TYPE = 'gate'
    env.CODE_PLATFORM = 'gitee'
    env.ORGANIZATION_NAME = "${giteeTargetNamespace}".toLowerCase()
    env.REPOSITORY_NAME = "${giteeTargetRepoName}".toLowerCase()
    env.GIT_USER_EMAIL = "${giteeUserEmail}"
    env.GIT_SOURCE_BRANCH = "${giteeSourceBranch}"
    env.GIT_TARGET_BRANCH = "${giteeTargetBranch}"
    env.GIT_PR_NUMBER = "${giteePullRequestIid}"
    env.PIPELINE_GATE_TYPE = 'MS_ALL'
    
    // Event type
    if (giteeActionType.toUpperCase() == 'NOTE') {
        env.GIT_TRIGGER_PHRASE = "${giteeTriggerPhrase}"
    } else {
        env.GIT_TRIGGER_PHRASE = '/retest'
    }

    // UT grouping
    if (env.REPOSITORY_NAME == "mindspore") {
        env.UT_GROUPS = 10
        env.UT_THREAD_NUMS = 24
    }
    
    // CI repo
    setEnvCI(env.GIT_SOURCE_BRANCH)
}

def setEnvVersion(String platformType='gitee') {
    env.PIPELINE_TYPE = "${PIPELINE_TYPE}"
    env.CODE_PLATFORM = 'gitee'
    env.ORGANIZATION_NAME = "${ORGANIZATION_NAME}".toLowerCase()
    env.REPOSITORY_NAME = "${REPOSITORY_NAME}".toLowerCase()
    env.GIT_TARGET_BRANCH = "${TARGET_BRANCH}"
    env.NEWEST_FLAG = "${NEWEST_FLAG}"

    // Used only for pipeline gate
    env.GIT_USER_EMAIL = 'NULL'
    env.GIT_SOURCE_BRANCH = 'NULL'
    env.GIT_PR_NUMBER = 'NULL'
    env.GIT_TRIGGER_PHRASE = 'NULL'

    // UT grouping
    if (env.REPOSITORY_NAME == "mindspore")  {
        env.UT_GROUPS = 10
        env.UT_THREAD_NUMS = 24
    }
    
    // CI repo
    setEnvCI(env.GIT_SOURCE_BRANCH)
}


/*
###############
# Common func #
###############
*/
def excuteShellScript(String jobName, String scriptPath, String paramsList='') {
    sh label: jobName, script: """
    #!/bin/bash
    set +xe
    
    # Running on agent
    echo "Agent: ${NODE_NAME} (${JENKINS_URL}computer/${NODE_NAME})"
    
    # Source assert
    source ${CODE_PATH}/ms-pipeline/public/assert.sh
    [ \$? -ne 0 ] &amp;&amp; echo "[ERROR] Source assert is failed." &amp;&amp; exit 1
    
    # Execute script
    sh ${CODE_PATH}/ms-pipeline/${scriptPath} -w ${WORKSPACE} ${paramsList}
    DP_ASSERT_EQUAL "\$?" "0" "Execute project of ${jobName}"
    """
}

def excuteBatScript(String jobName, String scriptPath, String paramsList='') {
    withCredentials([sshUserPrivateKey(credentialsId: 'share_compute_rsa_jenkins', keyFileVariable: 'SHARE_COMPUTER_RSA_KEY', usernameVariable: 'SHARE_COMPUTER_RSA_USR')]) {
        bat label: jobName, script: """
        @echo off
        @rem Running on agent
        echo Agent: ${NODE_NAME} (${JENKINS_URL}computer/${NODE_NAME})
        
        @rem Set env
        SET GIT_BASH=C:\\Program Files\\Git\\bin\\bash
        SET WINRAR=C:\\Program Files\\WinRAR\\winrar
        SET SCP=scp -q -r -o StrictHostKeychecking=no -i %SHARE_COMPUTER_RSA_KEY%
        SET RETURNCODE=0
    
        @rem Copy ms-pipeline
        "%GIT_BASH%" -c "cd \${WORKSPACE}; rm -rf ms-pipeline &amp;&amp; rm -f ms-pipeline.tar"
        "%GIT_BASH%" -c "\${SCP} ${SHARE_COMPUTER_RSA_USR}@${SHARE_COMPUTER_SMALL_IP}:${CODE_PATH}/ms-pipeline.tar \${WORKSPACE}"
        IF NOT %errorlevel% == 0 (
            echo [ERROR] Copy ms-pipeline is failed.
            set RETURNCODE=1
            goto run_end
        )
        cd /d %WORKSPACE%
        "%WINRAR%" x -y ms-pipeline.tar
    
        @rem Call script
        call ${WORKSPACE}\\ms-pipeline\\${scriptPath} "%WORKSPACE%" "${CODE_PATH}" "${PIPELINE_TYPE}" ${paramsList}
        IF NOT %errorlevel% == 0 (
            echo [ERROR] Execute project of ${jobName} is failed.
            set RETURNCODE=1
            goto run_end
        )
        echo [INFO] Execute project of ${jobName} is success.
    
        :run_end
            exit /b %RETURNCODE%
        """
    }
}

def commonLinux(String jobName, String nodeLabel, int projectTimeout, String scriptPath, String paramsList='') {
    node("${nodeLabel}") {
        ws("workspace/${jobName}") {
            timeout(time: projectTimeout, unit: 'MINUTES') {
                cleanWs()
                excuteShellScript(jobName, scriptPath, paramsList)
            }
        }
    }
}

def credentialsLinux(String jobName, String nodeLabel, int projectTimeout, String scriptPath, String paramsList='') {
    node("${nodeLabel}") {
        ws("workspace/${jobName}") {
            timeout(time: projectTimeout, unit: 'MINUTES') {
                cleanWs()
                withCredentials([usernamePassword(credentialsId: 'mindspore_community_jenkins_gitee', passwordVariable: 'GITEE_CREDENTIAL_PSW', usernameVariable: 'GITEE_CREDENTIAL_USR')]) {
                    excuteShellScript(jobName, scriptPath, paramsList)
                }
            }
        }
    }
}

def commonWindows(String jobName, String nodeLabel, int projectTimeout, String scriptPath, String paramsList='') {
    node("${nodeLabel}"){
        ws("workspace/${jobName}") {
            timeout(time: projectTimeout, unit: 'MINUTES') {
                cleanWs()
                excuteBatScript(jobName, scriptPath, paramsList)
            }
        }
    }
}

def getParallelJobs(def jobsList, def funcName, def scriptDirPath='') {
    def parallelJobsRun = [:]
    jobsList.each { job -&gt;
        def jobName = job[0]
        def nodeLabel = job[1]
        def projectTimeout = job[2]
        def scriptPath = scriptDirPath + job[3]
        def paramsList = job[4]
        def branch = {
            if (paramsList) {
                funcName(jobName, nodeLabel, projectTimeout, scriptPath, paramsList)
            } else {
                funcName(jobName, nodeLabel, projectTimeout, scriptPath)
            }
        }
        parallelJobsRun["${jobName}"] = branch
    }
    return parallelJobsRun
}

def getParallelFunc(def jobsList, def funcName, def paramsList='') {
    def parallelJobsRun = [:]
    jobsList.each { job -&gt;
        def branch = {
            if (paramsList) {
                funcName(paramsList)
            } else {
                funcName()
            }
        }
        parallelJobsRun["${job}"] = branch
    }
    return parallelJobsRun
}

/*
#############
# Init Gate #
#############
*/
def addOrRemoveLabel(String OWNER, String PROJECT, String PR_NUMBER, String ACCESS_TOKEN, ArrayList ADD_LABELS, ArrayList REMOVE_LABLES) {
    if (!(OWNER?.trim() &amp;&amp; PROJECT?.trim() &amp;&amp; PR_NUMBER?.trim() &amp;&amp; ACCESS_TOKEN?.trim()))  {
        throw new Exception("[ERROR] Any of 'OWNER', 'PROJECT', 'PR_NUMBER', 'ACCESS_TOKEN' should not be empty")
    }
    for (int i = 0; i &lt; 3; i++) {
        try {
            // Delete PR label
            println "[INFO] Going to update pr label. URL:https://gitee.com/${OWNER}/${PROJECT}/pulls/${PR_NUMBER}, Add:${ADD_LABELS}, Delete:${REMOVE_LABLES}"
            REMOVE_LABLES.eachWithIndex { v, index -&gt;
                def requestUrl = sprintf("https://gitee.com/api/v5/repos/%s/%s/pulls/%s/labels/%s?access_token=%s", OWNER, PROJECT, PR_NUMBER, v, ACCESS_TOKEN)
                println requestUrl
                def response = httpRequest quiet: true, consoleLogResponseBody: false,
                               contentType: 'APPLICATION_JSON',
                               customHeaders: [[name: "User-Agent", value: "MindSpore"]],
                               httpMode: 'DELETE',
                               url: requestUrl,
                               ignoreSslErrors: true,
                               validResponseCodes: "204,404";
                println response
                return response
            }

            // Add new PR label
            def requestUrl = sprintf("https://gitee.com/api/v5/repos/%s/%s/pulls/%s/labels?access_token=%s", OWNER, PROJECT, PR_NUMBER, ACCESS_TOKEN)
            def prNameStr = ADD_LABELS.join(',')
            def updatedLabels = """
                                ["${prNameStr}"]
                                """
            println requestUrl
            def response = httpRequest quiet: true, consoleLogResponseBody: false,
                           contentType: 'APPLICATION_JSON',
                           customHeaders: [[name: "User-Agent", value: "MindSpore"]],
                           httpMode: 'POST',
                           requestBody: updatedLabels,
                           url: requestUrl,
                           ignoreSslErrors: true,
                           validResponseCodes: "201";
            println response
            return response
        } catch(Exception ex) {
            println "[WARNING] Exception:${ex}"
        }
        if (i == 2) {
            println "[ERROR] Failed to update pr label. URL:https://gitee.com/${OWNER}/${PROJECT}/pulls/${PR_NUMBER}, Add:${ADD_LABELS}, Delete:${REMOVE_LABLES}"
            return false
        }
        sleep(3)
    }
}

def addPullRequestLabel(String owner, String repo, String prNumber, ArrayList addLabel) {
    ArrayList removeLabel = ["ci-pipeline-passed", "ci-pipeline-passed-t", "ci-pipeline-failed", "ci-pipeline-running"]
    withCredentials([string(credentialsId: 'gitee_token_id', variable: 'GITEE_TOKEN')]) {
        this.addOrRemoveLabel(owner, repo, prNumber, "${GITEE_TOKEN}", addLabel, removeLabel)
    }
}

def getCodeCheckToken() {
    // Get token
    withCredentials([string(credentialsId: 'code_check_token_id', variable: 'CODE_CHECK_TOKEN')]) {
        for (int i = 0; i &lt; 3; i++){
            def response = httpRequest \
                           contentType: 'APPLICATION_JSON_UTF8',
                           httpMode: 'GET',
                           url: "https://majun.osinfra.cn:8384/api/openlibing/codecheck/token/${CODE_CHECK_TOKEN}",
                           validResponseCodes: "200,500";
            if (response.status == 200) {
                def jsonRet = readJSON text: response.content
                if ( jsonRet.code == "200" ) {
                    return jsonRet.data
                }
            }

            if (i == 2) {
                println "[ERROR] Get code check token failed, please check."
                return false
            }
        }
    }

}

def triggerCodeCheck(String owner, String repo, String prNumber) {
    // Get token
    def dyToken = getCodeCheckToken()

    if (!dyToken){
        return false
    }
    // Code check
    for (int i = 0; i &lt; 3; i++){
        def response = httpRequest \
                       contentType: 'APPLICATION_JSON_UTF8',
                       httpMode: 'GET',
                       url: "https://majun.osinfra.cn:8384/api/openlibing/codecheck/task?pr_url=https://gitee.com/${owner}/${repo}/pulls/${prNumber}&amp;token=${dyToken}",
                       validResponseCodes: "200,500";
        if (response.status == 200) {
            def jsonRet = readJSON text: response.content
            if ( jsonRet.code == "200" ) {
                env.CODE_CHECK_TASK_ID = jsonRet.task_id
                env.CODE_CHECK_UUID = jsonRet.uuid
                return true
            } else {
                println "[WARNING] The code check error is: ${jsonRet.msg}"
                if (i==2) {
                    return true
                }
                continue
            }
        }

        if (i == 2) {
            println "[ERROR] Trigger code check failed, please check."
            return false
        }
    }
}

def getCodeCheckResult() {
    // Get token
    def dyToken = getCodeCheckToken()

    if (!dyToken){
        return false
    }

    // Get result
    if (!env.CODE_CHECK_TASK_ID) {
        def jsonRet = [state: "pass"]
        return jsonRet
    }
    for (int i = 0; i &lt; 6; i++){
        def response = httpRequest \
                       contentType: 'APPLICATION_JSON_UTF8',
                       httpMode: 'GET',
                       url: "https://majun.osinfra.cn:8384/api/openlibing/codecheck/${CODE_CHECK_TASK_ID}/status?uuid=${CODE_CHECK_UUID}&amp;token=${dyToken}",
                       validResponseCodes: "200,500";
        if (response.status == 200) {
            def jsonRet = readJSON text: response.content
            if ( jsonRet.code == "200" ) {
                return jsonRet
            } else if (jsonRet.code == "100") {
                if (i==5) {
                    println '[ERROR] Does not get code check result.'
                    return false
                }
                sleep(10)
                continue
            } else {
                println "[ERROR] The code check error is: ${jsonRet.msg}"
                return false
            }
        }
        if (i==5) {
            println '[ERROR] Does not get code check result.'
            return false
        }
        sleep(10)
    }
}

def postStatusOfPipelineRunning(String owner, String repo, String prNumber, Boolean codeCheck=false) {
    sleep(3)
    retry(3) {
        addGiteeMRComment comment: ":large_blue_circle: The pipeline is running. Please wait a moment... ([Link](${RUN_DISPLAY_URL}))"
    }

    addPullRequestLabel(owner, repo, prNumber, ["ci-pipeline-running"])

    // Code check
    if (codeCheck) {
        if (!triggerCodeCheck(owner, repo, prNumber)){
            sh 'exit 1'
        }
    }
}

def codeCheckRunning(String owner, String repo, String prNumber) {
    retry(3) {
        addGiteeMRComment comment: ":large_blue_circle: The code check is running. Please wait a moment... ([Link](${RUN_DISPLAY_URL}))"
    }

    // Code check
    if (!triggerCodeCheck(owner, repo, prNumber)){
        sh 'exit 1'
    }

    sleep(240)

    // Comment result
    def commentResult = "| Project Name | Build Result | Details |\n| --- | --- | --- |\n"

    // Get Code check Result
    def jsonRet = getCodeCheckResult()
    if (jsonRet &amp;&amp; jsonRet.state == "pass" ) {
        commentResult = commentResult + "|  Code_Check | :green_heart: **SUCCESS** | [RESULT](${jsonRet.data}) |\n"
    }else if (jsonRet &amp;&amp; jsonRet.state == "no pass" ) {
        commentResult = commentResult + "|  Code_Check | :x: **FAILURE** | [RESULT](${jsonRet.data}) |\n"
    }else{
        commentResult = commentResult + "|  Code_Check | :x: **ERROR** | NO RESULT |\n"
    }
    retry(3) {
        addGiteeMRComment comment: "${commentResult}"
    }
}

def checkCodeCheckResult(int checkTimes=1) {
    for (int i = 0; i &lt; checkTimes; i++) {
        if (!env.CODE_CHECK_RET) {
            def jsonRet = getCodeCheckResult()
            if (jsonRet &amp;&amp; jsonRet.state == 'no pass') {
                sh 'exit 1'
            } else if (jsonRet &amp;&amp; jsonRet.state == 'pass') {
                env.CODE_CHECK_RET = 'pass'
            }
            if (checkTimes == 1 || (jsonRet &amp;&amp; jsonRet.state == 'pass' &amp;&amp; jsonRet.data)) {
                break
            } else {
                sleep(60)
            }
        }
    }
}

// Node grouping
def nodeGrouping(String nodePrefix, Map groupInfo) {
    def nodeGroupMap = [:]
    def nodeNum = 0

    for ( groupType in groupInfo ) {
        nodeGroupMap[groupType.key] = ""
        def endNum = nodeNum + groupType.value

        for (groupId in nodeNum..&lt;endNum) {
            if ( !nodeGroupMap[groupType.key] ) {
                nodeGroupMap[groupType.key] = "${nodePrefix}-${groupId}"
            } else {
                nodeGroupMap[groupType.key] += " || ${nodePrefix}-${groupId}"
            }
        }
        nodeNum += groupType.value
    }
    return nodeGroupMap
}


/*
#################
# Download code #
#################
*/
def downloadCode(String jobName, String nodeLabel, int projectTimeout, String scriptPath) {
    node("${nodeLabel}"){
        ws("workspace/${jobName}") {
            timeout(time: projectTimeout, unit: 'MINUTES') {
                cleanWs()

                withCredentials([usernamePassword(credentialsId: 'mindspore_community_jenkins_gitee', passwordVariable: 'GITEE_CREDENTIAL_PSW', usernameVariable: 'GITEE_CREDENTIAL_USR')]) {
                    sh label: jobName, script: """
                    #!/bin/bash
                    set +xe

                    # Running on agent
                    echo "Agent: ${NODE_NAME} (${JENKINS_URL}computer/${NODE_NAME})"

                    # Git clone code of ms-pipeline
                    echo -e "\n[INFO] Git clone code of ms-pipeline."
                    for ((i=0; i&lt;3; i++)); do
                        rm -rf ${WORKSPACE}/ms-pipeline
                        git clone https://${GITEE_CREDENTIAL_USR}:${GITEE_CREDENTIAL_PSW}@gitee.com/${CI_PIPELINE_ORGANIZATION_NAME}/ms-pipeline.git -b ${CI_PIPELINE_BRANCH}
                        [ \$? -eq 0 ] &amp;&amp; break
                    done
                    [ \${i} -eq 3 ] &amp;&amp; echo "[ERROR] Git clone code of ms-pipeline is failed." &amp;&amp; exit 1
                    ls -ld ${WORKSPACE}/ms-pipeline

                    # Get ci branch
                    /usr/local/python/python375/bin/python3 ${WORKSPACE}/ms-pipeline/pipeline/bin/code/get_branch.py --config_path=${WORKSPACE}/ms-pipeline/pipeline/conf/mapping/mapping_branch.yaml --repo_name=${REPOSITORY_NAME} --target_branch=${GIT_TARGET_BRANCH} &gt; ${WORKSPACE}/get_branch.log 2&gt;&amp;1
                    CI_TARGET_BRANCH=\$(cat ${WORKSPACE}/get_branch.log|tail -n 1|grep 'ci_target_branch: '|awk '{print \$NF}')
                    if [ -z "\${CI_TARGET_BRANCH}" ]; then
                        CI_TARGET_BRANCH=${GIT_TARGET_BRANCH}
                    fi

                    # Git checkout branch
                    if [ "${CI_PIPELINE_ORGANIZATION_NAME}" = "mindspore" ] &amp;&amp; [ "\${CI_TARGET_BRANCH}" != "master" ]; then
                        cd ${WORKSPACE}/ms-pipeline
                        git branch -a|grep "remotes/origin/\${CI_TARGET_BRANCH}\$" &gt; /dev/null 2&gt;&amp;1
                        if [ \$? -eq 0 ] &amp;&amp; [ "\${CI_TARGET_BRANCH}" != "${CI_PIPELINE_BRANCH}" ]; then
                            echo -e "\n[INFO] Git checkout branch."
                            git checkout \${CI_TARGET_BRANCH}
                            git branch
                        fi
                    fi

                    # Support third-party organization
                    if [ ! -d "${WORKSPACE}/ms-pipeline/pipeline/mindspore/${REPOSITORY_NAME}/config/${ORGANIZATION_NAME}" ]; then
                        cp -a ${WORKSPACE}/ms-pipeline/pipeline/mindspore/${REPOSITORY_NAME}/config/mindspore ${WORKSPACE}/ms-pipeline/pipeline/mindspore/${REPOSITORY_NAME}/config/${ORGANIZATION_NAME}
                    fi

                    # Source assert
                    source ${WORKSPACE}/ms-pipeline/public/assert.sh
                    [ \$? -ne 0 ] &amp;&amp; echo "[ERROR] Source assert is failed." &amp;&amp; exit 1

                    # Download code
                    sh ${WORKSPACE}/ms-pipeline/${scriptPath} -w "${WORKSPACE}" -p "${CODE_PLATFORM}" -o "${ORGANIZATION_NAME}" -r "${REPOSITORY_NAME}" -e "${GIT_USER_EMAIL}" -s "${GIT_SOURCE_BRANCH}" -m "${GIT_TARGET_BRANCH}" -n "${GIT_PR_NUMBER}" -g "${GIT_TRIGGER_PHRASE}" -t "${PIPELINE_TYPE}" -b "${BUILD_ID}" -j "${JOB_NAME}"
                    DP_ASSERT_EQUAL "\$?" "0" "Execute project of ${jobName}"
                    """
                }
            }
        }
    }
}


/*
##############
# Code check #
##############
*/
def codeCheckResultAnalysis(String jobName) {
    if ("${jobName}" == "Check_Cppcheck") {
        recordIssues(tools: [cppCheck(pattern: 'cppcheck-style.xml')])
        sh label: 'Cppcheck Result', script: """set +xe; echo "${jobName}: &lt;${BUILD_URL}cppcheck&gt;";"""
    } else if ("${jobName}" == "Check_Cpplint") {
        recordIssues(tools: [cppLint(pattern: 'cpplint.log')])
        sh label: 'Cpplint Result', script: """set +xe; echo "${jobName}: &lt;${BUILD_URL}cpplint&gt;";"""
    } else if ("${jobName}" == "Check_Pylint") {
        recordIssues(tools: [pyLint(pattern: 'pylint.log')])
        sh label: 'Pylint Result', script: """set +xe; echo "${jobName}: &lt;${BUILD_URL}pylint&gt;";"""
    }
}
def codeCheckWithCredentialsId(String jobName, String scriptPath, String paramsList=''){
    withCredentials([string(credentialsId: paramsList, variable: 'credentialsId')]) {
         excuteShellScript(jobName, scriptPath, paramsList)
        if(jobName=="Check_Scanoss"){
                def sbomPath = "${CODE_PATH}/ms-pipeline/pipeline/bin/code/sbom.json"
                def sourceFile = "${WORKSPACE}/${REPOSITORY_NAME}"
                def resultUrl = "https://api.osinfra.cn"
                 for (int i = 0; i &lt; 3; i++) {
                    try{
                        sca authCode: "${credentialsId}", credentialsId: '', method: 'WebHook', methodChoose: '0', sbomFile:" ${sbomPath}", scanossCredentials: '', sourceFile: "${sourceFile}", sudoOrder: '', url: "${resultUrl}", urlChoose: ''
                        break
                    }catch (Exception ex) {
                        println("scanoss pr failed ${i} time")
                        if (i == 2) {
                            println "[ERROR] Failed to Scan pr by scanoss with reason ${ex}"
                            sh 'exit 1'
                        }
                    } 
                }
               excuteShellScript('checkResult','pipeline/bin/check/check_scanoss_result.sh','')
            }
        }
}
def codeCheck(String jobName, String nodeLabel, int projectTimeout, String scriptPath, String paramsList='') {
    node("${nodeLabel}") {
        ws("workspace/${jobName}") {
            timeout(time: projectTimeout, unit: 'MINUTES') {
                cleanWs()
                try {
                    if(jobName=="Check_Scanoss"){
                        codeCheckWithCredentialsId( jobName, scriptPath, paramsList)
                    }else{
                        excuteShellScript(jobName, scriptPath, paramsList)
                    }
                } catch (Exception ex) {
                    codeCheckResultAnalysis(jobName)
                    sh 'exit 1'
                }
            }
        }
    }
}

def codeCheck_Version(String jobName, String nodeLabel, int projectTimeout, String scriptPath, String paramsList='') {
    node("${nodeLabel}") {
        ws("workspace/${jobName}") {
            timeout(time: projectTimeout, unit: 'MINUTES') {
                cleanWs()
                try {
                    excuteShellScript(jobName, scriptPath, paramsList)
                } catch (Exception ex) {
                    codeCheckResultAnalysis(jobName)
                    if (['Check_ClangFormat'].contains(jobName)) {
                        sh 'exit 1'
                    }
                }
            }
        }
    }
}

def codeCheck_Docs(String jobName, String nodeLabel, int projectTimeout, String scriptPath, String paramsList='') {
    node("${nodeLabel}") {
        ws("workspace/${jobName}") {
            timeout(time: projectTimeout, unit: 'MINUTES') {
                cleanWs()
                try {
                    excuteShellScript(jobName, scriptPath, paramsList)
                } catch (Exception ex) {
                    codeCheckResultAnalysis(jobName)
                    if (['Check_Markdownlint', 'Check_Tab', 'Check_Codespell', 'Check_Rstlint', 'Check_Notebooklint'].contains(jobName)) {
                        sh 'exit 1'
                    }

                    // For docs repo
                    if ((env.REPOSITORY_NAME == 'docs') &amp;&amp; (jobName == 'Check_Pylint')) {
                        sh 'exit 1'
                    }
                }
            }
        }
    }
}

def codeCheckStage(String owner, String repo, String pipelineType) {
    // Pylint timeout
    def timeoutPylint = 30
    def timeoutCpplint = 30
    if (pipelineType != 'gate') {
        timeoutPylint = 120
    }

    // Job list
    def jobsList = [["Check_ClangFormat", "x86-check-ubuntu", 10, "check_clangformat.sh"],
                    ["Check_Cppcheck", "x86-check-ubuntu", 10, "check_cppcheck.sh"],
                    ["Check_Cpplint", "x86-check-ubuntu", timeoutCpplint, "check_cpplint.sh"],
                    ["Check_Pylint", "x86-check-ubuntu", timeoutPylint, "check_pylint.sh"],
                    ["Check_Rstlint", "x86-check-ubuntu", 10, "check_rstlint.sh"],
                    ["Check_Linklint", "x86-check-ubuntu", timeoutPylint, "check_linklint.sh"],
                    ["Check_Shellcheck", "x86-check-ubuntu", 10, "check_shellcheck.sh"],
                    ["Check_Markdownlint", "x86-check-ubuntu", 10, "check_markdownlint.sh"],
                    ["Check_Tab", "x86-check-ubuntu", 10, "check_tab.sh"],
                    ["Check_Cmakelint", "x86-check-ubuntu", 10, "check_cmakelint.sh"],
                    ["Check_Notebooklint", "x86-check-ubuntu", 10, "check_notebooklint.sh"],
                    ["Check_Codespell", "x86-check-ubuntu", 10, "check_codespell.sh"],
                    ["Check_Darglint", "x86-check-ubuntu", timeoutPylint, "check_darglint.sh"],
                    ["Check_Lizard", "x86-check-ubuntu", 10, "check_lizard.sh"]]

    // For code diff
    if (pipelineType == 'gate') {
        jobsList += [["Check_DT_Design", "x86-check-ubuntu", 10, "check_different.sh"]]
        jobsList += [["Check_Scanoss", "x86-check-ubuntu", 10, "check_scanoss.sh", 'SCANOSS_TOKEN']]
    }

    // For code docs
    if ((pipelineType == 'gate') &amp;&amp; (GIT_SOURCE_BRANCH.length() &gt;= 9) &amp;&amp; (GIT_SOURCE_BRANCH.substring(0,9) == 'code_docs')) {
        jobsList -= [["Check_Lizard", "x86-check-ubuntu", 10, "check_lizard.sh"]]
    }

    def funcName = this.&amp;codeCheck_Version
    if (pipelineType == 'gate') {
        if (['book', 'community', 'course', 'docs'].contains(repo)) {
            funcName = this.&amp;codeCheck_Docs
        } else {
            funcName = this.&amp;codeCheck
        }

        // For graphengine or code sync
        if (['graphengine', 'akg', 'akg-binary'].contains(repo) || ((GIT_SOURCE_BRANCH.length() &gt;= 9) &amp;&amp; (GIT_SOURCE_BRANCH.substring(0,9) == 'code_sync'))) {
            funcName = this.&amp;codeCheck_Version
        }
    }

    return getParallelJobs(jobsList, funcName, "pipeline/bin/check/")
}


/*
##############
# Smoke test #
##############
*/
def excuteSmokeScript(String jobName, String scriptPath, String paramsList='') {
    withCredentials([sshUserPrivateKey(credentialsId: 'share_compute_rsa_jenkins', keyFileVariable: 'SHARE_COMPUTER_RSA_KEY', usernameVariable: 'SHARE_COMPUTER_RSA_USR'), usernamePassword(credentialsId: 'ftp-smoke-log-jenkins', passwordVariable: 'FTP_SMOKE_LOG_PSW', usernameVariable: 'FTP_SMOKE_LOG_USR'), usernamePassword(credentialsId: 'user_root', passwordVariable: 'SMOKE_REBOOT_PSW', usernameVariable: 'SMOKE_REBOOT_USR')]) {
        sh label: jobName, script: """
        #!/bin/bash
        set +xe

        # Running on agent
        echo "Agent: ${NODE_NAME} (${JENKINS_URL}computer/${NODE_NAME})"

        # Copy ms-pipeline
        cd ${WORKSPACE}
        rm -f ms-pipeline.tar
        scp -q -r -o StrictHostKeychecking=no -i ${SHARE_COMPUTER_RSA_KEY} ${SHARE_COMPUTER_RSA_USR}@${SHARE_COMPUTER_BIG_IP}:${CODE_PATH}/ms-pipeline.tar ${WORKSPACE}/
        [ \$? -ne 0 ] &amp;&amp; echo "[ERROR] Copy ms-pipeline is failed." &amp;&amp; exit 1
        rm -rf ms-pipeline
        tar -xf ms-pipeline.tar &gt; /dev/null 2&gt;&amp;1

        # Source assert
        source ${WORKSPACE}/ms-pipeline/public/assert.sh
        [ \$? -ne 0 ] &amp;&amp; echo "[ERROR] Source assert is failed." &amp;&amp; exit 1

        # Execute script
        sh ${WORKSPACE}/ms-pipeline/${scriptPath} -w ${WORKSPACE} ${paramsList}
        DP_ASSERT_EQUAL "\$?" "0" "Execute project of ${jobName}"
        """
    }
}

def smokeTest(String jobName, String nodeLabel, int projectTimeout, String scriptPath, String paramsList='') {
    node("${nodeLabel}") {
        ws("workspace/${jobName}") {
            timeout(time: projectTimeout, unit: 'MINUTES') {
                cleanWs()
                excuteSmokeScript(jobName, scriptPath, paramsList)
            }
        }
    }
}

def smokeTest2(String jobName, String nodeLabel, int projectTimeout, String scriptPath, String paramsList='') {
    node("${nodeLabel}") {
        ws("workspace/${jobName}") {
            timeout(time: projectTimeout, unit: 'MINUTES') {
                cleanWs()
                try {
                    excuteSmokeScript(jobName, scriptPath, paramsList)
                } catch(Exception ex) {
                    println("[ERROR] Excute ${jobName} failed, exception is ${ex}.")
                }
            }
        }
    }
}

def smokeTest2_NPU(String jobName, String nodeLabel, int projectTimeout, String scriptPath, String paramsList='') {
    withCredentials([usernamePassword(credentialsId: 'download_from_repo_ftp', passwordVariable: 'REPO_FTP_DOWNLOAD_PSW', usernameVariable: 'REPO_FTP_DOWNLOAD_USR')]) {
        smokeTest(jobName, nodeLabel, projectTimeout, scriptPath, paramsList)
    }
}

def smokeTest2_CPU(String jobName, String nodeLabel, int projectTimeout, String scriptPath, String paramsList='') {
    withCredentials([usernamePassword(credentialsId: 'download_from_repo_ftp', passwordVariable: 'REPO_FTP_DOWNLOAD_PSW', usernameVariable: 'REPO_FTP_DOWNLOAD_USR')]) {
        commonLinux(jobName, nodeLabel, projectTimeout, scriptPath, paramsList)
    }
}

def getSmokeNodeLabel(def organizationName, def repositoryName, def targetBranch, def nodeType='ascend910') {
    def smokeNodeLabel = ''
    if (nodeType == 'gpu') {
        smokeNodeLabel = 'smoke-gpu'
    } else if (nodeType == 'lite') {
        smokeNodeLabel = 'smoke-lite'
    } else if (nodeType =~ 'ascend') {
        if (organizationName == 'ms-incubator') {
            smokeNodeLabel = "smoke-${nodeType}-incubator"
        } else {
            if (targetBranch != 'master') {
                smokeNodeLabel = "smoke-${nodeType}-${targetBranch}"
            } else {
                smokeNodeLabel = "smoke-${nodeType}"
            }
        }
    }

    return smokeNodeLabel
}


/*
###############
# Release FTP #
###############
*/
def releaseFTP(String jobName, String nodeLabel, int projectTimeout, String scriptPath, String paramsList='') {
    node("${nodeLabel}") {
        ws("workspace/${jobName}") {
            timeout(time: projectTimeout, unit: 'MINUTES') {
                cleanWs()
                withCredentials([sshUserPrivateKey(credentialsId: 'repo.mindspore.cn', keyFileVariable: 'REPO_FTP_KEY', passphraseVariable: '', usernameVariable: 'REPO_FTP_USER')]) {
                    excuteShellScript(jobName, scriptPath, paramsList)
                }
            }
        }
    }
}

def releasePYPI(String jobName, String nodeLabel, int projectTimeout, String scriptPath, String paramsList='') {
    node("${nodeLabel}") {
        ws("workspace/${jobName}") {
            timeout(time: projectTimeout, unit: 'MINUTES') {
                cleanWs()
                withCredentials([usernamePassword(credentialsId: 'mindspore_pypi', passwordVariable: 'PYPI_PWD', usernameVariable: 'PYPI_USR')]) {
                    excuteSmokeScript(jobName, scriptPath, paramsList)
                }
            }
        }
    }
}

def releasePackageOfPYPI() {
    def jobsList = [["Release_PYPI", "update-build", 180, "release_pypi_version.sh"]]
    return getParallelJobs(jobsList, this.&amp;releasePYPI, "pipeline/bin/release/")
}

def releasePackageOfPipeline(String pipelineType, String newestFlag='') {
    def jobsList = []
    if (pipelineType == 'gate') {
        jobsList = [["Release_FTP", "x86-check-ubuntu", 15, "release_ftp_gate.sh"]]
    } else {
        jobsList = [["Release_FTP", "x86-check-ubuntu", 60, "release_ftp_version.sh", "-f ${newestFlag}"]]
    }
    return getParallelJobs(jobsList, this.&amp;releaseFTP, "pipeline/bin/release/")
}


/*
########
# Post #
########
*/
def deletePipelineCode(String codePath) {
    node('x86-check-ubuntu') {
        timeout(time: 5, unit: 'MINUTES') {
            sh label: "Delete_Code", script: """
                rm -rf ${codePath}
            """
        }
    }
}

// Delete comments
//   Comment1: /retest*
//   Comment2: The pipeline is running. Please wait a moment...
def deleteGiteeComments(String owner, String repo, String prNumber) {
    node('x86-check-ubuntu') {
        ws("workspace/Delete_Comments") {
            timeout(time: 3, unit: 'MINUTES') {
                cleanWs()
                withCredentials([string(credentialsId: 'gitee_token_id', variable: 'GITEE_TOKEN')]) {
                    sh label: 'Delete_Comments', script: """
                    #!/bin/bash
                    set +xe

                    # Running on agent
                    echo "Agent: ${NODE_NAME} (${JENKINS_URL}computer/${NODE_NAME})"

                    # Source assert
                    source ${CODE_PATH}/ms-pipeline/public/assert.sh
                    [ \$? -ne 0 ] &amp;&amp; echo "[ERROR] Source assert is failed." &amp;&amp; exit 1

                    # Execute script
                    echo -e "\n[INFO] Delete comments."
                    /usr/local/python/python375/bin/python3 ${CODE_PATH}/ms-pipeline/pipeline/bin/gitee/gitee_comments.py -f ${CODE_PATH}/ms-pipeline/pipeline/conf/gitee/gitee_api.yaml -a ${GITEE_TOKEN} -o ${owner} -r ${repo} -p ${prNumber} -t delete &gt; ${WORKSPACE}/gitee_comments.log 2&gt;&amp;1
                    if [ \$? -ne 0 ]; then
                        cat ${WORKSPACE}/gitee_comments.log
                    fi
                    """
                }
            }
        }
    }
}

def postResultOfPipelineGate(String owner, String repo, String prNumber, String pipelineResult, String codePath='/tmp/ms', String pipelineMode='GATE', Boolean codeCheck=false) {
    println("currentBuild.result = ${pipelineResult}")

    // Get path of release package
    def releasePath = ""
    try {
        releasePath = readFile("${codePath}/release_path.txt").trim().replaceAll("\\s*|\t|\r|\n", "")
    } catch(Exception ex) {
        println "[WARNING] Read file(${codePath}/release_path.txt) is failed."
    }

    // Set successIcon
    def successIcon = 'white_check_mark'
    def successLabel = ["ci-pipeline-passed"]

    // Debug mode
    if(pipelineMode == 'DEBUG') {
        successIcon = 'green_heart'
        successLabel = ["ci-pipeline-passed-t"]
    }

    // Comment result
    def commentResult = "| Project Name | Build Result | Details |\n| --- | --- | --- |\n"
    def codeCheckSuccess = true

    // Get Code check result
	if (codeCheck &amp;&amp; pipelineResult != 'ABORTED') {
        // Code check
        def jsonRet = getCodeCheckResult()
		if (jsonRet &amp;&amp; jsonRet['data']) {
			result="[RESULT](${jsonRet.data})"
		} else{
			result="RESULT"
		}
        if (jsonRet &amp;&amp; (jsonRet['state'] == 'pass')) {
            commentResult = commentResult + "|  Code_Check | :${successIcon}: **SUCCESS** | ${result} |\n"
        } else if (jsonRet &amp;&amp; jsonRet['state'] == 'no pass') {
            commentResult = commentResult + "|  Code_Check | :x: **FAILURE** | ${result} |\n"
            codeCheckSuccess = false
        }
    }
    
    // Report result
    if (pipelineResult == 'SUCCESS') {
        retry(3) {
            addGiteeMRComment comment: "${commentResult}|  [${JOB_NAME}](${releasePath}) | :${successIcon}: **SUCCESS** | [${BUILD_ID}](${RUN_DISPLAY_URL}) |\n"
        }
        addPullRequestLabel(owner, repo, prNumber, successLabel)
        if (codeCheckSuccess){
            addPullRequestLabel(owner, repo, prNumber, successLabel)
        } else {
            addPullRequestLabel(owner, repo, prNumber, ["ci-pipeline-failed"])
        }
        echo '[INFO] The pipeline run success.'
    } else {
        retry(3) {
            addGiteeMRComment comment: "${commentResult}|  [${JOB_NAME}](${releasePath}) | :x: **FAILURE** | [${BUILD_ID}](${RUN_DISPLAY_URL}) |\n"
        }
        addPullRequestLabel(owner, repo, prNumber, ["ci-pipeline-failed"])
        echo '[ERROR] The pipeline run failed.'
    }
    
    // Delete obsolete comments
    if(pipelineMode != 'DEBUG') {
        deleteGiteeComments(owner, repo, prNumber)
    }
    
    // Delete code
    deletePipelineCode(codePath)
}

def postResultOfPipelineVersion(String pipelineResult, String codePath='/tmp/ms', String pipelineMode='VERSION') {
    println("currentBuild.result = ${pipelineResult}")
    if(pipelineResult == 'SUCCESS') {
        echo '[INFO] The pipeline run success.'
    } else {
        echo '[ERROR] The pipeline run failed.'
    }
    
    // Release logs
    if(pipelineMode != 'DEBUG') {
        releaseFTP("Release_Logs", "x86-check-ubuntu", 10, "pipeline/bin/release/release_logs_version.sh", "-n ${JOB_NAME}")
    }
    
    // Delete code
    deletePipelineCode(codePath)
}


/*
####################
# Ascend so update #
####################
*/
def extractSO() {
    def jobsList = [["Extract_Ascend_SO", "smoke-nfs-30", 180, "extract_ascend_so.sh", "-s hisi"]]
    return getParallelJobs(jobsList, this.&amp;extractSoOfAscend, "tools/ascend/compile/")
}

def extractSoOfAscend (String jobName, String nodeLabel, int projectTimeout, String scriptPath, String paramsList=''){
    node("${nodeLabel}") {
        ws("workspace/${jobName}") {
            timeout(time: projectTimeout, unit: 'MINUTES'){
                cleanWs()

                withCredentials([sshUserPrivateKey(credentialsId: 'share_compute_rsa_jenkins', keyFileVariable: 'SHARE_COMPUTER_RSA_KEY', usernameVariable: 'SHARE_COMPUTER_RSA_USR'), usernamePassword(credentialsId: 'share_computer_jenkins', passwordVariable: 'SHARE_COMPUTER_PSW', usernameVariable: 'SHARE_COMPUTER_USER')]) {
                    sh label: jobName, script: """
                    #!/bin/bash
                    set +xe

                    # Running on agent
                    echo "Agent: ${NODE_NAME} (${JENKINS_URL}computer/${NODE_NAME})"

                    # Copy ms-pipeline
                    cd ${WORKSPACE}
                    rm -f ms-pipeline.tar
                    scp -q -r -o StrictHostKeychecking=no -i ${SHARE_COMPUTER_RSA_KEY} ${SHARE_COMPUTER_RSA_USR}@${SHARE_COMPUTER_BIG_IP}:${CODE_PATH}/ms-pipeline.tar ${WORKSPACE}/
                    [ \$? -ne 0 ] &amp;&amp; echo "[ERROR] Copy ms-pipeline is failed." &amp;&amp; exit 1
                    rm -rf ms-pipeline
                    tar -xf ms-pipeline.tar &gt; /dev/null 2&gt;&amp;1

                    # Source assert
                    source ${WORKSPACE}/ms-pipeline/public/assert.sh
                    [ \$? -ne 0 ] &amp;&amp; echo "[ERROR] Source assert is failed." &amp;&amp; exit 1

                    # Execute script
                    sh ${WORKSPACE}/ms-pipeline/${scriptPath} -w ${WORKSPACE} ${paramsList}
                    DP_ASSERT_EQUAL "\$?" "0" "Execute project of ${jobName}"
                    """
                }
            }
        }
    }
}

/*
#############################
# Ascend run package update #
#############################
*/
def checkUpgradeEnv(String jobName, String nodeLabel, String envType, String operationType="driver-&gt;firmware", String uninstallFlag="true", int projectTimeout=100) {
    node("${nodeLabel}") {
        // Get nodeLabel
        def upgradeNodeLabel = "smoke-ascend910-upgrade"
        def nodeLabelName = "smoke-ascend"
        def nodeTrueName = ""
        def upgradeInfoMap = [:]
        if (envType == "ASCEND910") {
            nodeTrueName = "smoke-ascend-"
            if (GIT_TARGET_BRANCH == "master") {
                upgradeNodeLabel = "smoke-ascend910-upgrade"
                nodeLabelName = "smoke-ascend"
            } else {
                upgradeNodeLabel = "smoke-ascend910-${GIT_TARGET_BRANCH}-upgrade"
                nodeLabelName = "smoke-ascend"
            }
        } else if (envType == "ASCEND310") {
            nodeTrueName = "smoke-ascend310-"
            if (GIT_TARGET_BRANCH == "master") {
                upgradeNodeLabel = "smoke-ascend310-upgrade"
                nodeLabelName = "smoke-ascend"
            } else {
                upgradeNodeLabel = "smoke-ascend310-${GIT_TARGET_BRANCH}-upgrade"
                nodeLabelName = "smoke-ascend"
            }
        }
        def nodeLists=nodesByLabel "${upgradeNodeLabel}"
        if (nodeLists) {
            return
        }

        // Get path of release package
        def nodeIP=""
        def versionDate=""
        def nodeListMatcher=""
        def nodeNamesList=[]
        try {
            def envStr = readFile("${CODE_PATH}/ms-pipeline/pipeline/conf/env/env.sh").trim()
            def driverTypeMatcher = envStr =~ /ASCEND910_DRIVER_PKG_PATH=.*\/ascend910\/(\d+)/
            def toolsTypeMatcher = envStr =~ /ASCEND910_TOOLS_PKG_PATH=.*\/ascend910\/(\d+)/
            if (envType == 'ASCEND910') {
                nodeListMatcher = envStr =~ /ASCEND910_NODES="(.*)"/
            } else if (envType == 'ASCEND310') {
                nodeListMatcher = envStr =~ /ASCEND310_NODES="(.*)"/
            }
            if (driverTypeMatcher) {
                upgradeInfoMap["driver_version_date"]=driverTypeMatcher[-1][-1]
                println "[INFO] The driver run package date of upgrade is $upgradeInfoMap.driver_version_date ."
            }
            if (toolsTypeMatcher) {
                upgradeInfoMap["tools_version_date"]=toolsTypeMatcher[-1][-1]
                println "[INFO] The tools run package date of upgrade is $upgradeInfoMap.tools_version_date ."
            }
            if (nodeListMatcher) {
                nodeIP=nodeListMatcher[0][1]
                nodeTrueName += nodeIP.split(",")[0].split('\\.')[-1]
                upgradeInfoMap["node_ip"]=nodeIP
                upgradeInfoMap["node_true_name"]=nodeTrueName
                println "[INFO] The update run package node is ${nodeTrueName}."
            }
        } catch(Exception ex) {
            println "[WARNING] Read file env.sh is failed, error is ${ex}."
            return
        }

        // Reset label
        println "[INFO] Ready to set node label to none."
        def hudsonOb = hudson.model.Hudson.instance
        hudsonOb.slaves.findAll { it.nodeName.contains("${nodeTrueName}") }.each { slave -&gt;
            println "[INFO] Begin to set node ${slave.nodeName} label to none."
            slave.labelString = ""
            nodeNamesList &lt;&lt; slave.nodeName
        }
        hudsonOb.save()
        println "[INFO] Set node label to none success."
        upgradeInfoMap["node_names_list"]=nodeNamesList

        if (envType == 'ASCEND910') {
            env.ASCEND910_UPGRADE_MAP = groovy.json.JsonOutput.toJson(upgradeInfoMap)
        } else if (envType == 'ASCEND310') {
            env.ASCEND310_UPGRADE_MAP = groovy.json.JsonOutput.toJson(upgradeInfoMap)
        }
    }
}

def checkNodeBusy(String jobName, String nodeTrueName) {
    // check node whether running
    println "[INFO] Begin to check the node of ${nodeTrueName} whether free."
    node("${nodeTrueName}") {
        sh label: jobName, script: """
        #!/bin/bash
        set +xe

        # Running on agent
        echo "The Agent ${NODE_NAME} now is free."
        """
    }
}

def updateRunPkg(String jobName, String nodeIPList, String driverVersionDate, String toolsVersionDate, String versionType="euleros2.8_aarch64", String operationType="driver-&gt;firmware", String uninstallFlag="true", int projectTimeout=100) {
    // update run package
    node("smoke-schedule-30") {
        ws("workspace/${jobName}") {
            cleanWs()
            timeout(time: projectTimeout, unit: 'MINUTES'){
                withEnv(["NODE_IP_LIST=${nodeIPList}", "DRIVER_VERSION_DATE=${driverVersionDate}", "TOOLS_VERSION_DATE=${toolsVersionDate}", "VERSION_TYPE=${versionType}", "OPERATOR_TYPE=${operationType}", "UNINSTALL_FLAG=${uninstallFlag}"]) {
                    withCredentials([sshUserPrivateKey(credentialsId: 'share_compute_rsa_jenkins', keyFileVariable: 'SHARE_COMPUTER_RSA_KEY', usernameVariable: 'SHARE_COMPUTER_RSA_USR'), usernamePassword(credentialsId: 'user_root', passwordVariable: 'BLUE_ASCEND_PASSWORD', usernameVariable: 'BLUE_ASCEND_USER')]) {
                        sh label: jobName, script: """
                        #!/bin/bash
                        set +xe

                        # Running on agent
                        echo "Agent: ${NODE_NAME} (${JENKINS_URL}computer/${NODE_NAME})"

                        # Copy ms-pipeline
                        cd ${WORKSPACE}
                        rm -f ms-pipeline.tar
                        scp -q -r -o StrictHostKeychecking=no -i ${SHARE_COMPUTER_RSA_KEY} ${SHARE_COMPUTER_RSA_USR}@${SHARE_COMPUTER_BIG_IP}:${CODE_PATH}/ms-pipeline.tar ${WORKSPACE}/
                        [ \$? -ne 0 ] &amp;&amp; echo "[ERROR] Copy ms-pipeline is failed." &amp;&amp; exit 1
                        rm -rf ms-pipeline
                        tar -xf ms-pipeline.tar &gt; /dev/null 2&gt;&amp;1

                        # Source assert
                        source ${WORKSPACE}/ms-pipeline/public/assert.sh
                        [ \$? -ne 0 ] &amp;&amp; echo "[ERROR] Source assert is failed." &amp;&amp; exit 1

                        # Execute script
                        sh ${WORKSPACE}/ms-pipeline/tools/ascend/deploy/deploy_ascend.sh
                        DP_ASSERT_EQUAL "\$?" "0" "Update ${driverVersionDate} ascend run package"
                        """
                    }
                }
                println "[INFO] Update node of ${nodeIPList} run package ${driverVersionDate} is success."
            }
        }
    }
}

def setNodeLabel(String nodeTrueName, String envType) {
    // Set upgrade node label
    println "[INFO] Ready to set node  ${nodeTrueName} label to upgrade."
    def hudsonOb = hudson.model.Hudson.instance
    hudsonOb.slaves.findAll { it.nodeName.contains("${nodeTrueName}") }.each { slave -&gt;
        if (envType == "ASCEND910") {
            if (GIT_TARGET_BRANCH == "master") {
                slave.labelString = "smoke-ascend910-upgrade"
            } else {
                slave.labelString = "smoke-ascend910-${GIT_TARGET_BRANCH}-upgrade"
            }
        } else if (envType == "ASCEND310") {
            if (GIT_TARGET_BRANCH == "master") {
                slave.labelString = "smoke-ascend310-upgrade"
            } else {
                slave.labelString = "smoke-ascend310-${GIT_TARGET_BRANCH}-upgrade"
            }
        }
        println "[INFO] Set node  ${nodeTrueName} label to ${slave.labelString} is success."
    }
    hudsonOb.save()
}

node('x86-generic-slaves') {
    this.setEnvGate('gitee')

    try {
        stage('post-status'){
            this.postStatusOfPipelineRunning(ORGANIZATION_NAME, REPOSITORY_NAME, GIT_PR_NUMBER, true)
        }
        stage('download-code') {
            this.downloadCode("Download_Code", "x86-check-ubuntu", 20, "pipeline/bin/code/download_code.sh")
            if (GIT_SOURCE_BRANCH =~ 'upgrade_ascend') {
                this.checkUpgradeEnv("Confirm_Upgrade_Ascend310", 'x86-check-ubuntu', "ASCEND310")
                this.checkUpgradeEnv("Confirm_Upgrade_Ascend910", 'x86-check-ubuntu', "ASCEND910")
            }
            PIPELINE_TASK_TYPE = readFile("${CODE_PATH}/task_type.txt").trim().replaceAll("\\s*|\t|\r|\n", "")
        }
        stage('code-check') {
            def parallelJobsRun = [:]

            if (GIT_SOURCE_BRANCH =~ 'upgrade_ascend') {
                parallelJobsRun &lt;&lt; this.extractSO()
            }

            // Whether upgrade ascend910
            if (env.ASCEND910_UPGRADE_MAP) {
                def ascend910UpdateMap = readJSON text: env.ASCEND910_UPGRADE_MAP
                def nodeTrueName = ascend910UpdateMap["node_names_list"][0]
                def branch = {
                    this.&amp;checkNodeBusy("Confirm_Free_(${nodeTrueName})", nodeTrueName)
                }
                parallelJobsRun["Confirm_Free_${nodeTrueName}"] = branch
            }

            // Whether upgrade ascend310
            if (env.ASCEND310_UPGRADE_MAP) {
                def ascend310UpdateMap = readJSON text: env.ASCEND310_UPGRADE_MAP
                def nodeNameList = ascend310UpdateMap["node_names_list"]
                nodeNameList.each { nodeTrueName -&gt;
                    def branch = {
                        this.&amp;checkNodeBusy("Confirm_Free_(${nodeTrueName})", nodeTrueName)
                    }
                    parallelJobsRun["Confirm_Free_${nodeTrueName}"] = branch
                }
            }

            parallelJobsRun &lt;&lt; this.codeCheckStage(ORGANIZATION_NAME, REPOSITORY_NAME, PIPELINE_TYPE)
            parallel parallelJobsRun
        }
        stage('compile') {
            def parallelJobsRun = [:]

            // Node group
            def ubuntuX86Labels = this.nodeGrouping('x86-ubuntu-slaves', ['lite1': 15, 'lite2': 8])
            def centosX86Labels = this.nodeGrouping('x86-centos-slaves', ['cpu': 15, 'gpu1': 15, 'gpu2': 15, 'ascend/lite': 31, 'ut': 20])
            def centosARMLabels = this.nodeGrouping('arm-centos-slaves', ['ascend910': 16, 'ascend310': 10])
            def windowsLabels = this.nodeGrouping('x86-windows-slaves', ['sse': 6, 'lite': 6, 'avx': 9, 'ut': 15])

            // Linux cloud
            def jobsList = []
            if (['MS_ALL', 'MS_FL', 'MS_CLOUD', 'MS_CLOUD_CPU_AND_LITE', 'MS_CLOUD_ASCEND',  'MS_CLOUD_GPU', 'MS_CLOUD_CPU', 'MS_CLOUD_UT', 'MS_CLOUD_UT_CPP', 'MS_CLOUD_UT_PYTHON'].contains(PIPELINE_TASK_TYPE.toString())) {
                jobsList += [["Compile_UT", centosX86Labels['ut'], 90, "mindspore_compile.sh", "-p ms-ut"]]
            }
            if (['MS_ALL', 'MS_CLOUD', 'MS_CLOUD_ASCEND'].contains(PIPELINE_TASK_TYPE.toString())) {
                jobsList += [["Compile_Ascend_ARM_CentOS", centosARMLabels['ascend910'], 90, "mindspore_compile.sh", "-p ascend -t centos_aarch64 -c ascend910"],
                             ["Compile_Ascend310_ARM_CentOS", centosARMLabels['ascend310'], 90, "mindspore_compile.sh", "-p ascend -t centos_aarch64 -c ascend310"]]
            }
            if (['MS_ALL', 'MS_FL', 'MS_CLOUD', 'MS_CLOUD_GPU'].contains(PIPELINE_TASK_TYPE.toString())) {
                jobsList += [["Compile_GPU_X86_CentOS_Cuda10", centosX86Labels['gpu1'], 90, "mindspore_compile.sh", "-p gpu -t centos_x86 -c cuda-10.1"],
                             ["Compile_GPU_X86_CentOS_Cuda11", centosX86Labels['gpu2'], 90, "mindspore_compile.sh", "-p gpu -t centos_x86 -c cuda-11.1"]]
            }
            if (['MS_ALL', 'MS_FL', 'MS_CLOUD', 'MS_CLOUD_CPU_AND_LITE', 'MS_CLOUD_CPU'].contains(PIPELINE_TASK_TYPE.toString())) {
                jobsList += [["Compile_CPU_X86_CentOS", centosX86Labels['cpu'], 90, "mindspore_compile.sh", "-p cpu -t centos_x86"]]
            }

            // Linux lite
            if (['MS_ALL', 'MS_FL', 'MS_LITE', 'MS_CLOUD_CPU_AND_LITE'].contains(PIPELINE_TASK_TYPE.toString())) {
                jobsList += [["Compile_Lite_Java", ubuntuX86Labels['lite1'], 45, "mindspore_compile.sh", "-p lite -t aar -g java"],
                             ["Compile_Lite_Java_DATA", ubuntuX86Labels['lite1'], 45, "mindspore_compile.sh", "-p lite -t aar -g java -i data"],
                             ["Compile_Lite_ARM32", ubuntuX86Labels['lite1'], 45, "mindspore_compile.sh", "-p lite -t android_aarch32 -e npu"],
                             ["Compile_Lite_ARM32_CPU", ubuntuX86Labels['lite1'], 45, "mindspore_compile.sh", "-p lite -t android_aarch32 -e cpu"],
                             ["Compile_Lite_ARM32_OHOS", ubuntuX86Labels['lite1'], 45, "mindspore_compile.sh", "-p lite -t ohos_aarch32"],
                             ["Compile_Lite_ARM32_3519A", ubuntuX86Labels['lite1'], 45, "mindspore_compile.sh", "-p lite -t linux_aarch32 -i Hi3519A"],
                             ["Compile_Lite_ARM64", ubuntuX86Labels['lite2'], 45, "mindspore_compile.sh", "-p lite -t android_aarch64 -e npu"],
                             ["Compile_Lite_ARM64_3559A", ubuntuX86Labels['lite2'], 45, "mindspore_compile.sh", "-p lite -t linux_aarch64 -i Hi3559A"],
                             ["Compile_Lite_ARM64_SD3403", ubuntuX86Labels['lite2'], 45, "mindspore_compile.sh", "-p lite -t linux_aarch64 -i SD3403"],
                             ["Compile_Lite_ARM64_CROP", ubuntuX86Labels['lite2'], 45, "mindspore_compile.sh", "-p lite -t android_aarch64 -e cpu -i cropping"],
                             ["Compile_Lite_ARM64_Linux", "arm-build-centos", 45, "mindspore_compile.sh", "-p lite -t linux_aarch64"],
                             ["Compile_Lite_ARM64_SERVER", "arm-build-centos", 45, "mindspore_compile.sh", "-p lite -t linux_aarch64 -i server"],
                             ["Compile_Lite_X86", centosX86Labels['ascend/lite'], 45, "mindspore_compile.sh", "-p lite -t centos_x86"],
                             ["Compile_Lite_X86_SSE", centosX86Labels['ascend/lite'], 45, "mindspore_compile.sh", "-p lite -t centos_x86 -i sse"],
                             ["Compile_Lite_X86_AVX", centosX86Labels['ascend/lite'], 45, "mindspore_compile.sh", "-p lite -t centos_x86 -i avx"],
                             ["Compile_Lite_X86_AVX512", centosX86Labels['ascend/lite'], 45, "mindspore_compile.sh", "-p lite -t centos_x86 -i avx512"],
                             ["Compile_Lite_X86_TRT", centosX86Labels['ascend/lite'], 45, "mindspore_compile.sh", "-p lite -t centos_x86 -c cuda-11.1 -i tensorrt"],
                             ["Compile_Lite_X86_SERVER", centosX86Labels['ascend/lite'], 45, "mindspore_compile.sh", "-p lite -t centos_x86 -i server"],
                             ["Compile_Lite_X86_ASCEND", centosX86Labels['ascend/lite'], 45, "mindspore_compile.sh", "-p lite -t centos_x86 -c ascend310 -i ascend"],
                             ["Compile_Lite_X86_ASCEND_Online", centosX86Labels['ascend/lite'], 45, "mindspore_compile.sh", "-p lite -t centos_x86 -c ascend310 -i ascend_online"],
                             ["Compile_Lite_X86_SERVER_GPU", centosX86Labels['ascend/lite'], 45, "mindspore_compile.sh", "-p lite -t centos_x86 -c cuda-11.1 -i server_tensorrt"],
                             ["Compile_Lite_X86_ASAN", centosX86Labels['ascend/lite'], 45, "mindspore_compile.sh", "-p lite -t centos_x86 -i asan"],
                             ["Compile_Lite_X86_SD3403", centosX86Labels['ascend/lite'], 45, "mindspore_compile.sh", "-p lite -t centos_x86 -i SD3403"],
                             ["Compile_Lite_X86_CORTEX-M7", centosX86Labels['ascend/lite'], 45, "mindspore_compile.sh", "-p lite -t centos_x86 -i cortex-m7"]]
            }

            // Windows cloud
            def jobsList2 = []
            if (['MS_ALL', 'MS_FL', 'MS_CLOUD', 'MS_CLOUD_CPU_AND_LITE', 'MS_CLOUD_CPU'].contains(PIPELINE_TASK_TYPE.toString())) {
                jobsList2 += [["Compile_CPU_Windows", windowsLabels['ut'], 100, "mindspore_compile.bat", "cpu"]]
            }

            // Windows lite
            if (['MS_ALL', 'MS_FL', 'MS_LITE', 'MS_CLOUD_CPU_AND_LITE'].contains(PIPELINE_TASK_TYPE.toString())) {
                jobsList2 += [["Compile_Lite_Windows_AVX", windowsLabels['avx'], 60, "mindspore_compile.bat", "lite avx"],
                              ["Compile_Lite_Windows", windowsLabels['lite'], 60, "mindspore_compile.bat", "lite"],
                              //["Compile_Lite_Windows_Win32", windowsLabels['lite'], 60, "mindspore_compile.bat", "lite win32"],
                              ["Compile_Lite_Windows_SSE", windowsLabels['sse'], 60, "mindspore_compile.bat", "lite sse"]]
            }

            // Linux lite
            def jobsList3 = []
            if (['MS_ALL', 'MS_FL', 'MS_LITE', 'MS_CLOUD_CPU_AND_LITE'].contains(PIPELINE_TASK_TYPE.toString())) {
                jobsList3 += [["Compile_Lite_ARM32_3516D", ubuntuX86Labels['lite1'], 45, "mindspore_compile.sh", "-p lite -t linux_aarch32 -i Hi3516D"],
                              ["Compile_Lite_X86_3516D", centosX86Labels['ascend/lite'], 45, "mindspore_compile.sh", "-p lite -t centos_x86 -i Hi3516D"]]
            }

            // MacOS cloud
            def jobsList4 = []
            if (['MS_ALL', 'MS_FL', 'MS_CLOUD', 'MS_CLOUD_CPU_AND_LITE', 'MS_CLOUD_CPU'].contains(PIPELINE_TASK_TYPE.toString())) {
                jobsList4 += [["Compile_CPU_X86_MacOS", "x86-build-macos", 90, "mindspore_compile.sh", "-p cpu -t macos_x86"]]
            }

            // Run jobs
            parallelJobsRun &lt;&lt; this.getParallelJobs(jobsList, this.&amp;commonLinux, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/")
            parallelJobsRun &lt;&lt; this.getParallelJobs(jobsList2, this.&amp;commonWindows, "pipeline\\mindspore\\${REPOSITORY_NAME}\\scripts\\windows\\")
            parallelJobsRun &lt;&lt; this.getParallelJobs(jobsList3, this.&amp;credentialsLinux, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/")
            parallelJobsRun &lt;&lt; this.getParallelJobs(jobsList4, this.&amp;smokeTest, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/")
            parallelJobsRun &lt;&lt; this.getParallelFunc(['Code_Check'], this.&amp;checkCodeCheckResult)

            // Upgrade ascend
            if (env.ASCEND910_UPGRADE_MAP || env.ASCEND310_UPGRADE_MAP) {
                // Upgrade ascend910
                if (env.ASCEND910_UPGRADE_MAP) {
                    def ascend910UpdateMap = readJSON text: env.ASCEND910_UPGRADE_MAP
                    println ascend910UpdateMap
                    def branch = {
                        this.&amp;updateRunPkg("Upgrade_Ascend910", ascend910UpdateMap["node_ip"], ascend910UpdateMap["driver_version_date"], ascend910UpdateMap["tools_version_date"])
                    }
                    parallelJobsRun["Upgrade_Ascend910_Run_Pkg"] = branch
                }

                // Upgrade ascend310
                if (env.ASCEND310_UPGRADE_MAP) {
                    def ascend310UpdateMap = readJSON text: env.ASCEND310_UPGRADE_MAP
                    println ascend310UpdateMap
                    def branch = {
                        this.&amp;updateRunPkg("Upgrade_Ascend310", ascend310UpdateMap["node_ip"], ascend310UpdateMap["driver_version_date"], ascend310UpdateMap["tools_version_date"])
                    }
                    parallelJobsRun["Upgrade_Ascend310_Run_Pkg"] = branch
                }
            } else {
                parallelJobsRun.failFast = true
            }

            parallel parallelJobsRun
        }
        stage('ut-test') {
            def parallelJobsRun = [:]

            // Linux cloud
            def jobsList = []
            if (['MS_ALL', 'MS_FL', 'MS_CLOUD', 'MS_CLOUD_CPU_AND_LITE', 'MS_CLOUD_ASCEND',  'MS_CLOUD_GPU', 'MS_CLOUD_CPU',  'MS_CLOUD_UT', 'MS_CLOUD_UT_CPP'].contains(PIPELINE_TASK_TYPE.toString())) {
                jobsList += [["UT_CPP", "x86-build-centos", 15, "ut_test.sh", "-t cpp"]]
            }
            if (['MS_ALL', 'MS_FL', 'MS_CLOUD', 'MS_CLOUD_CPU_AND_LITE', 'MS_CLOUD_ASCEND',  'MS_CLOUD_GPU', 'MS_CLOUD_CPU',  'MS_CLOUD_UT', 'MS_CLOUD_UT_PYTHON'].contains(PIPELINE_TASK_TYPE.toString())) {
                def j = 0
                for (int i = 0; i &lt; UT_GROUPS.toInteger(); i++) {
                    j = i + 1
                    jobsList += [["UT_Python_Group${j}", "x86-build-centos", 10, "ut_test.sh", "-t python -g ${i}"]]
                }
            }

            // Windows lite
            def jobsList2 = []
            if (['MS_ALL', 'MS_FL', 'MS_LITE', 'MS_CLOUD_CPU_AND_LITE'].contains(PIPELINE_TASK_TYPE.toString())) {
                jobsList2 += [["Smoke_Lite_Windows_AVX", "x86-build-windows", 15, "mindspore_smoke_lite.bat", "avx"]]
            }
            // Lite ut
            def jobsList3 = []
            if (['MS_ALL', 'MS_FL', 'MS_LITE', 'MS_CLOUD_CPU_AND_LITE'].contains(PIPELINE_TASK_TYPE.toString())) {
                smokeNodeLabelLite_3 = "smoke-lite-huawei || lite3-ms${BUILD_ID}"
                jobsList3 += [["UT_Lite", smokeNodeLabelLite_3, 30, "mindspore_ut_lite.sh"]]
            }
            // Run jobs
            parallelJobsRun &lt;&lt; this.getParallelJobs(jobsList, this.&amp;commonLinux, "pipeline/bin/llt/ut/")
            parallelJobsRun &lt;&lt; this.getParallelJobs(jobsList2, this.&amp;commonWindows, "pipeline\\mindspore\\${REPOSITORY_NAME}\\scripts\\windows\\")
            parallelJobsRun &lt;&lt; this.getParallelJobs(jobsList3, this.&amp;smokeTest, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/")
            parallelJobsRun &lt;&lt; this.getParallelFunc(['Code_Check'], this.&amp;checkCodeCheckResult)

             // Update ascend910 label
            if (env.ASCEND910_UPGRADE_MAP || env.ASCEND310_UPGRADE_MAP) {
                if (env.ASCEND910_UPGRADE_MAP) {
                    def ascend910UpdateMap = readJSON text: env.ASCEND910_UPGRADE_MAP
                    def nodeTrueName = ascend910UpdateMap["node_names_list"][0]
                    def branch = {
                        this.&amp;setNodeLabel(nodeTrueName, 'ASCEND910')
                    }
                    parallelJobsRun["Update_${nodeTrueName}_Label"] = branch
                }

                // Update ascend910 label
                if (env.ASCEND310_UPGRADE_MAP) {
                    def ascend310UpdateMap = readJSON text: env.ASCEND310_UPGRADE_MAP
                    def nodeNameList = ascend310UpdateMap["node_names_list"]
                    nodeNameList.each { nodeTrueName -&gt;
                        def branch = {
                            this.&amp;setNodeLabel(nodeTrueName, 'ASCEND310')
                        }
                        parallelJobsRun["Update_${nodeTrueName}_Label"] = branch
                    }
                }
            } else {
                parallelJobsRun.failFast = true
            }

            parallel parallelJobsRun
        }
        stage('smoke-test') {
            def parallelJobsRun = [:]

            // Linux cloud
            def jobsList = []
            if (['MS_ALL', 'MS_CLOUD', 'MS_CLOUD_ASCEND'].contains(PIPELINE_TASK_TYPE.toString())) {
                def smokeNodeLabelAscend310 = this.getSmokeNodeLabel(ORGANIZATION_NAME, REPOSITORY_NAME, GIT_TARGET_BRANCH, 'ascend310')
                def smokeNodeLabelAscend910 = this.getSmokeNodeLabel(ORGANIZATION_NAME, REPOSITORY_NAME, GIT_TARGET_BRANCH, 'ascend910')

                // If upgrade ascend
                if (GIT_SOURCE_BRANCH =~ 'upgrade_ascend') {
                    smokeNodeLabelAscend310 = smokeNodeLabelAscend310 + '-upgrade'
                    smokeNodeLabelAscend910 = smokeNodeLabelAscend910 + '-upgrade'
                }

                // Support multiple label
                smokeNodeLabelAscend310 = "${smokeNodeLabelAscend310} || ascend310-ms${BUILD_ID}"
                smokeNodeLabelAscend910 = "${smokeNodeLabelAscend910} || ascend910-ms${BUILD_ID}"

                jobsList += [["Smoke_Ascend", smokeNodeLabelAscend910, 150, "pipeline/bin/llt/st/smoke_test.sh", "-p ascend"],
                             ["Smoke_Ascend310_CPP", smokeNodeLabelAscend310, 30, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_cpp.sh", "-c ascend310"],
                             ["Smoke_Ascend310_Python", smokeNodeLabelAscend310, 30, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_python.sh", "-c ascend310"]]
            }
            if (['MS_ALL', 'MS_FL', 'MS_CLOUD', 'MS_CLOUD_GPU'].contains(PIPELINE_TASK_TYPE.toString())) {
                def smokeNodeLabelGpu = this.getSmokeNodeLabel(ORGANIZATION_NAME, REPOSITORY_NAME, GIT_TARGET_BRANCH, 'gpu')
                smokeNodeLabelGpu = "${smokeNodeLabelGpu} || gpu-ms${BUILD_ID}"
                jobsList += [["Smoke_GPU", smokeNodeLabelGpu, 90, "pipeline/bin/llt/st/smoke_test.sh", "-p gpu -c cuda-11.1"]]
            }

            // Linux lite
            if (['MS_ALL', 'MS_FL', 'MS_LITE', 'MS_CLOUD_CPU_AND_LITE'].contains(PIPELINE_TASK_TYPE.toString())) {
                smokeNodeLabelLite_1 = "smoke-lite-x86 || lite-ms${BUILD_ID}"
                smokeNodeLabelLite_2 = "smoke-lite-phone-cpu || lite2-ms${BUILD_ID}"
                smokeNodeLabelLite_3 = "smoke-lite-phone-gpu || lite3-ms${BUILD_ID}"
                smokeNodeLabelLite_4 = "smoke-lite-phone-npu || lite4-ms${BUILD_ID}"
                smokeNodeLabelLite_5 = "smoke-lite-phone-gpu-gl || lite5-ms${BUILD_ID}"
                smokeNodeLabelLite_6 = "smoke-lite-gpu || lite6-ms${BUILD_ID}"
                smokeNodeLabelLite_7 = "smoke-lite-3516D || lite7-ms${BUILD_ID}"
                smokeNodeLabelLite_8 = "smoke-lite-cortex-m7 || lite8-ms${BUILD_ID}"
                jobsList += [["Smoke_Lite_X86_TF", 'x86-build-centos', 30, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t x86_tf"],
                             ["Smoke_Lite_X86_ONNX", 'x86-build-centos', 30, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t x86_onnx"],
                             ["Smoke_Lite_X86_TFLITE", 'x86-build-centos', 30, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t x86_tflite"],
                             ["Smoke_Lite_X86_CAFFE", 'x86-build-centos', 30, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t x86_caffe"],
                             ["Smoke_Lite_X86_MINDIR", 'x86-build-centos', 30, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t x86_mindir"],
                             ["Smoke_Lite_X86_QUANT", 'x86-build-centos', 30, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t x86_quant"],
                             ["Smoke_Lite_X86_ASAN", 'x86-build-centos', 30, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t x86_asan"],
                             ["Smoke_Lite_X86_TRT", smokeNodeLabelLite_6, 20, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t x86_gpu"],
                             ["Smoke_Lite_X86_SERVER_GPU", smokeNodeLabelLite_6, 20, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t server_inference_x86_gpu"],
                             ["Smoke_Lite_X86_Codegen", smokeNodeLabelLite_2, 20, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t codegen"],
                             ["Smoke_Lite_X86_CORTEX-M7", smokeNodeLabelLite_8, 20, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t cortex_codegen"],
                             ["Smoke_Lite_X86_Train", smokeNodeLabelLite_2, 20, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t train"],
                             ["Smoke_Lite_X86_SERVER", 'x86-build-centos', 30, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t server_inference_x86"],
                             ["Smoke_Lite_X86_AVX512_CAFFE", 'x86-build-centos', 30, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t x86_avx512_caffe"],
                             ["Smoke_Lite_X86_AVX512_TF", 'x86-build-centos', 30, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t x86_avx512_tf"],
                             ["Smoke_Lite_X86_AVX512_ONNX", 'x86-build-centos', 30, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t x86_avx512_onnx"],
                             ["Smoke_Lite_X86_AVX512_TFLITE", 'x86-build-centos', 30, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t x86_avx512_tflite"],
                             ["Smoke_Lite_X86_AVX512_MINDIR", 'x86-build-centos', 30, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t x86_avx512_mindir"],
                             ["Smoke_Lite_X86_ASCEND", 'smoke-lite-ascend310', 30, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t x86_ascend310"],
                             ["Smoke_Lite_SIM_SD3403", smokeNodeLabelLite_1, 20, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t simulation_sd3403"],
                             ["Smoke_Lite_ARM32", smokeNodeLabelLite_2, 20, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t arm32_cpu"],
                             ["Smoke_Lite_ARM32_3516D", smokeNodeLabelLite_7, 20, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t arm32_3516D"],
                             ["Smoke_Lite_ARM64_TF", smokeNodeLabelLite_2, 20, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t arm64_tf"],
                             ["Smoke_Lite_ARM64_ONNX", smokeNodeLabelLite_2, 20, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t arm64_onnx"],
                             ["Smoke_Lite_ARM64_TFLITE", smokeNodeLabelLite_2, 20, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t arm64_tflite"],
                             ["Smoke_Lite_ARM64_CAFFE", smokeNodeLabelLite_2, 20, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t arm64_caffe"],
                             ["Smoke_Lite_ARM64_MINDIR", smokeNodeLabelLite_2, 20, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t arm64_mindir"],
                             ["Smoke_Lite_ARM64_QUANT", smokeNodeLabelLite_2, 20, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t arm64_quant"],
                             ["Smoke_Lite_ARM64_CROP", smokeNodeLabelLite_2, 20, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t arm64_cpu_cropping"],
                             ["Smoke_Lite_ARM64_Linux_TFLITE", 'arm-build-centos', 30, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t linux_arm64_tflite"],
                             ["Smoke_Lite_ARM64_SERVER", "arm-build-centos", 30, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t server_inference_arm"],
                             ["Smoke_Lite_GPU_ONNX_MINDIR", smokeNodeLabelLite_3, 20, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t gpu_onnx_mindir"],
                             ["Smoke_Lite_GPU_TF_CAFFE", smokeNodeLabelLite_3, 20, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t gpu_tf_caffe"],
                             ["Smoke_Lite_GPU_TFLITE", smokeNodeLabelLite_3, 20, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t gpu_tflite"],
                             //["Smoke_Lite_GPU_GL", smokeNodeLabelLite_5, 10, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t gpu_gl_texture"],
                             ["Smoke_Lite_NPU", smokeNodeLabelLite_4, 20, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_lite.sh", "-t npu"]]
            }

            // Linux federal learning
            if (['MS_ALL', 'MS_FL'].contains(PIPELINE_TASK_TYPE.toString())) {
                jobsList += [["Smoke_FL_X86_CPU", 'x86-build-centos', 30, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/mindspore_smoke_federal.sh", "-t x86_cpu"]]
            }

            // Linux cloud
            def jobsList2 = []
            if (['MS_ALL', 'MS_FL', 'MS_CLOUD', 'MS_CLOUD_CPU_AND_LITE', 'MS_CLOUD_CPU'].contains(PIPELINE_TASK_TYPE.toString())) {
                jobsList2 += [["Smoke_CPU_CentOS_Level0", "x86-build-centos", 40, "pipeline/bin/llt/st/smoke_cpu.sh"],
                              ["Smoke_CPU_CentOS_Level1", "x86-build-centos", 20, "pipeline/bin/llt/st/smoke_cpu.sh", "-l level1 -r no"]]
            }

            // Windows cloud
            def jobsList3 = []
            //if (['MS_ALL', 'MS_FL', 'MS_CLOUD', 'MS_CLOUD_CPU_AND_LITE', 'MS_CLOUD_CPU'].contains(PIPELINE_TASK_TYPE.toString())) {
            //    jobsList3 += [["Smoke_CPU_Windows_Level0", "x86-build-windows", 20, "mindspore_smoke_cpu.bat", "level0 no"],
            //                  ["Smoke_CPU_Windows_Level1", "x86-build-windows", 20, "mindspore_smoke_cpu.bat", "level1 no"]]
            //}

            // Windows lite
            if (['MS_ALL', 'MS_FL', 'MS_LITE',  'MS_CLOUD_CPU_AND_LITE'].contains(PIPELINE_TASK_TYPE.toString())) {
                jobsList3 += [["Smoke_Lite_Windows", "x86-build-windows", 15, "mindspore_smoke_lite.bat", ""],
                              ["Smoke_Lite_Windows_SSE", "x86-build-windows", 15, "mindspore_smoke_lite.bat", "sse"]]
            }

            // Smoke MacOS
            def jobsList4 = []
            if (['MS_ALL', 'MS_FL', 'MS_CLOUD', 'MS_CLOUD_CPU_AND_LITE', 'MS_CLOUD_CPU'].contains(PIPELINE_TASK_TYPE.toString())) {
                jobsList4 += [["Smoke_CPU_MacOS_Level0", "x86-build-macos", 20, "mindspore_smoke_mac.sh", "-r no"],
                              ["Smoke_CPU_MacOS_Level1", "x86-build-macos", 20, "mindspore_smoke_mac.sh", "-l level1 -r no"]]
            }

            // Run jobs
            parallelJobsRun &lt;&lt; this.getParallelJobs(jobsList, this.&amp;smokeTest)
            parallelJobsRun &lt;&lt; this.getParallelJobs(jobsList2, this.&amp;commonLinux)
            parallelJobsRun &lt;&lt; this.getParallelJobs(jobsList3, this.&amp;commonWindows, "pipeline\\mindspore\\${REPOSITORY_NAME}\\scripts\\windows\\")
            parallelJobsRun &lt;&lt; this.getParallelJobs(jobsList4, this.&amp;smokeTest, "pipeline/mindspore/${REPOSITORY_NAME}/scripts/")
            if (['MS_ALL', 'MS_FL', 'MS_CLOUD', 'MS_LITE', 'MS_CLOUD_CPU_AND_LITE', 'MS_CLOUD_ASCEND', 'MS_CLOUD_GPU', 'MS_CLOUD_CPU'].contains(PIPELINE_TASK_TYPE.toString())) {
                parallelJobsRun &lt;&lt; this.releasePackageOfPipeline(PIPELINE_TYPE)
            }
            parallelJobsRun &lt;&lt; this.getParallelFunc(['Code_Check'], this.&amp;checkCodeCheckResult)

            parallelJobsRun.failFast = true
            parallel parallelJobsRun
        }
        currentBuild.result = 'SUCCESS'
    } catch(Exception ex) {
        println("[ERROR] ${ex}")
        currentBuild.result = 'FAILURE'
    } finally {
        this.postResultOfPipelineGate(ORGANIZATION_NAME, REPOSITORY_NAME, GIT_PR_NUMBER, currentBuild.result, CODE_PATH, 'GATE', true)
    }
}
</script>
    <sandbox>true</sandbox>
  </definition>
  <triggers/>
  <disabled>false</disabled>
</flow-definition>